# Динамическое программирование.

# Как не нужно делать! Асимптотика алгоритма экспотенциальна О(fib(n)).
def fib1(n):
    if n <= 1:
        return n
    else:
        return fib1(n - 1) + fib1(n - 2)


# print(fib1(33)) # для вычисления 33-го числа Фибоначчи потребуется НЕСКОЛЬКО секунд.
# Числа больше 35 практически невозможно найти за адекватное время.

# Вторая реализация - через массив. Асимптотика линейная O(n-2).
def fib(n):
    fib_list = [0, 1] + [0] * (n - 1)
    for i in range(2, n + 1):
        fib_list[i] = fib_list[i - 1] + fib_list[i - 2]
    return fib_list[n]


# print(fib(100_000))  # для вычисления 3333-го числа Фибоначчи требуется НЕСКОЛЬКО СОТЫХ секунды.
# print(len(str(fib(100_000))))


# Перепрыгивание между точками. Есть запрещённые точки. Нужно посчитать количество возможных траекторий.
# подсчёт количества траекторий
def count_trajectories(N, allowed: list):
    K = [0, 1, int(allowed[2])] + [0] * (N - 3)
    for i in range(3, N + 1):
        if allowed[i]:
            K[i] = K[i - 1] + K[i - 2] + K[i - 3]
    return K[N]


# example
print(count_trajectories(2, [0, 1, 9]))


# подсчёт наименьшей стоимости движения по траектории
def count_min_cost(N, price: list):
    C = [float("-inf"), price[1], price[1] + price[2]] + [0] * (N - 2)
    for i in range(3, N + 1):
        C[i] = price[i] + min(C[i - 1], C[i - 2])
    return C[N]


# example
print(count_min_cost(2, [1, 2, 3]))


# Двумерные массивы. Обход двумерных массивов.

# I. Первая раелизация.
# Aij = A[i*M+j] - если дан массив Aij (N-строк, M-элементов в строке), то такое выражение - это линеаризация массива.


# II. Вторая реализация. Список списков.

M = 5
N = 3
A = [[0]*M for i in range(N)]
print(*A, sep='\n')
print(A[0] == A[1], A[0] is A[1])


