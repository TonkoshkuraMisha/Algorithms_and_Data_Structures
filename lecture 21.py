# Множества. Set.
A = {1, '2', 3}
A1 = set()
A2 = set("qwerty")

# Добавление и удаление элементов множества
x = 1
print(x in A)  # принадлежность к множеству А элемента х.
print(x not in A)  # не принадлежность к множеству А элемента х.
y = 2
A.add(y)  # добавление к множеству А элемента У.
print(A)
# операций удаления элемента множества есть три.
A1.discard(x)
"""
Удаление элемента B.discard(x) без ответа на вопрос есть он там или нет.
Нежелательно использовать, потому что в случае, если его 
там нет, программа не выдаёт ошибок.
"""
A.remove(y)  # удаление элемента в случае, если он есть, а иначе - ошибка KeyError!
A.pop()  # удаление элемента с возвращением его значения.
print(A)

A = {}
B = {}
# Операции над множествами
# C1 = A | B  # объединение двух множеств
#D1 = A.union(B)  # объединение двух множеств

# C2 = A & B  # пересечение двух множеств
#D2 = A.intersection(B)  # пересечение двух множеств

# C3 = A - B  # вычитание двух множеств
#D3 = A.difference(B)  # вычитание двух множеств

# С4 = A ^ B  # симметричная разность

# Словари. Dict. Ассоциативные массивы
"""

"""
G = {}
F = dict()
D = {'one': 1, 'two': 2, 'three': 3} # {key_1: value_1, ...}

K = ('one', 'two', 'three', 'four')
V = [1, 2, 3, 4]
W = zip(K, V) # замечательная функция, объединяющая попарно элементы двух списков.
# Единственное условие - равенство длин списков.
for i in W:
    print(i)

Z = dict(zip(K, V))
print(Z)

Z['five'] = 5
print(Z)
print('five' in Z)
print('six' in Z)

# del Z['thr'] # удаление. возможна ошибка ключа KeyError.
x = Z.pop('three') # удаление с дефолт велью.
print(x)
y = Z.pop('thr', -1)
print(y)
print(Z)

# Пример использования словаря для частотного анализа.

votes = {}
N = int(input())
for i in range(N):
    name = input()
    if name in votes:
        votes[name] += 1
    else:
        votes[name] = 1
A = list(votes.items())